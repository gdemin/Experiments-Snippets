---
title: "Experiments&Snippets"
author: "Gregory Demin"
output: html_document
---

### 2014-11-08 Стандартное отклонение распределения выборочных средних (ЦПТ)

По идее, оно должно быть SD_выборки/sqrt(N_выборки) и не меняться с количеством повторов эксперимента. Эксперимент - это случайная выборка из N_sample элементов. Соответственно, мы повторяем этот эксперимент разное количество раз. 

```{r}

set.seed(20140811)

N_sample = 30
N_exp = c(10,50,100,200,500,1000,5000, 50000)

res = lapply(N_exp, function(N){
    experiments = replicate(N,mean(rnorm(N_sample)))
    c(mean = mean(experiments),sd = sd(experiments),sd_exper = 1/sqrt(N_sample))
    
    })

do.call(rbind,res) # две последние колонки должны быть примерно равны

```

Да, действительно не зависит от количества повторов. Впрочем, это было очевидно уже при написании программы. 
Заодно проверим покрытие - будет ли выборочное среднее в 95% случаях лежать в интервале +/-1.96*SD_выборки/sqrt(N_выборки).

```{r}

N_sample = 30
N_exp = c(10,50,100,200,500,1000,5000, 50000)

res = lapply(N_exp, function(N){
    experiments = replicate(N,abs(mean(rnorm(N_sample))) < 1.96/sqrt(N_sample))
    mean(experiments)
    
    })

do.call(rbind,res) # Должно быть в районе 0.95

```

Да, покрытие примерно 95%.


### 2014-11-08 Эксперименты с %>% и dplyr - интересно проверить, как он будет вести с any и if

```{r}
library(dplyr)
df = data.frame(a=1:5,b=5:1)

any(df$a<6) # должно быть TRUE

df$a<6 %>% any() # так не работает

df$a<6 %>% any # так не работает 

# оказывается проблема в приоритете операций
(df$a<6) %>% any() # так работает, правильное TRUE

# тест if - шансов мало
# (df$a<6) %>% any() %>% if() df$d=0 else df$d=1 # оно и не работает...

```

А общая идея была, чтобы можно было писать проверку в виде цепочек. 
Типа: 
df %>% check(a,1:5) %>% corr(99)  # то есть, наверное и так можно сделать, надо только функции доработать

Сложный вопрос - надо как-то получать имена переменных в номральном виде, как select в dplyr. Наверное, этот select и надо использовать. Типа, сначала запускаешь выделенное до corr, получаешь список ошибок. Потом, если запускаешь с corr, то будет исправление.
Вместо corr, наверное все-таки clean - чтобы не путать с корреляциями.
По пути надо таскать с собой атрибуты - текущая проверка, текущие переменные для условий. Хотя, может и лучше зафиксировать их раз и навсегда. Сделать в пакете константы. Надо как-то еще переменную id передавать.

Самая засада - надо бы удобный просмотрщик ошибок. И, может быть, набор алгоритмов исправления...



